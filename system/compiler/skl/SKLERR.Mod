MODULE SKLERR;
  TYPE
    ERRORTYPE* = INTEGER;

  CONST
    UndeclaredIdent*        =   0; (* undeclared identifier *)
    MultipleDefinition*      =   1; (* multiply defined identifier *)
    IllegalCharInNumber*    =   2; (* illegal character in number *)
    IllegalCharInString*    =   3; (* illegal character in string *)
    IdentMismatch*          =   4; (* identifier does not match procedure name *)
    CommentNotClosed*        =   5; (* comment not closed *)
    EqlExpected*            =   6; (* '=' expected *)
    BadTypeStart*            =   7; (* type definition starts with incorrect symbol *)
    BadFactorStart*          =   8; (* factor starts with incorrect symbol *)
    BadStatementStart*      =   9; (* statement starts with incorrect symbol *)
    BadDeclEnd*              =  10; (* declaration followed by incorrect symbol *)
    ModuleExpected*          =  11; (* MODULE expected *)
    PeriodExpected*          =  12; (* '.' missing *)
    CommaExpected*          =  13; (* ',' missing *)
    ColonExpected*          =  14; (* ':' missing *)
    RbrakExpected*          =  15; (* ']' missing *)
    RbraceExpected*          =  16; (* '}' missing *)
    OfExpected*              =  17; (* OF missing *)
    ThenExpected*            =  18; (* THEN missing *)
    DoExpected*              =  19; (* DO missing *)
    ToExpected*              =  20; (* TO missing *)
    LparenExpected*          =  21; (* '(' missing *)
    RparenExpected*          =  22; (* ')' missing *)
    BecomesExpected*        =  23; (* ':=' missing *)
    BadArrayDecl*            =  24; (* ',' or OF expected *)
    IdentExpected*          =  25; (* identifier expected *)
    SemicolonExpected*      =  26; (* ';' missing *)
    EndExpected*            =  27; (* END missing *)
    UntilExpected*          =  28; (* UNTIL missing *)
    MisplacedExit*          =  29; (* EXIT not within loop statement *)
    IllegalMark*            =  30; (* illegally marked identifier *)
    NotAConstant*            =  31; (* expression should be constant *)
    NotInteger*              =  32; (* constant not an integer *)
    NotAType*                =  33; (* identifier does not denote a type *)
    NotARecordType*          =  34; (* identifier does not denote a record type *)
    NotARecord*              =  35; (* identifier does not denote a record type *)
    IllegalResult*          =  36; (* result type of procedure is not a basic type *)
    IllegalPointsTo*        =  37; (* pointer not bound to record or array type *)
    RecursiveType*          =  38; (* recursive type definition *)
    IllegalOpenArrayParm*    =  39; (* illegal open array parameter *)
    WrongLabelType*          =  40; (* wrong type of case label *)
    IllegalLabelType*        =  41; (* inadmissible type of case label *)
    DuplicateLabel*          =  42; (* case label defined more than once *)
    LovalGtrHival*          =  43; (* high bound of range is less than low bound *)
    IllegalArraySize*        =  44; (* illegal dimension *)
    TooManyAparm*            =  45; (* more actual than formal parameters *)
    TooFewAparm*            =  46; (* fewer actual than formal parameters *)
    IllegalByValue*          =  47; (* value not legal for BY clause *)
    OpenArrayMismatch*      =  48; (* element types of actual array and formal open array differ *)
    NotSuitableOpenArray*    =  49; (* actual parameter corresponding to open array is not an array *)
    ConstInteger*            =  50; (* parameter must be an integer constant *)
    ReceiverError*          =  51; (* pointer or VAR record required as formal receiver *)
    PointerReceiver*        =  52; (* pointer expected as actual receiver *)
    BadReceiver*            =  53; (* procedure must be bound to a record of the same scope *)
    MustBeGlobalProc*        =  54; (* procedure must have level 0 *)
    BaseMethodNotFound*      =  55; (* procedure unknown in base type *)
    InvalidSupercall*        =  56; (* invalid call of base procedure *)
    ReadOnlyVariable*        =  57; (* this variable (field) is read only *)
    UndefinedField*          =  58; (* undefined record field *)
    IllegalOpenArray*        =  59; (* open array not allowed as variable, field or array element *)
    NeedBoolean*            =  60; (* a BOOLEAN type operand is required *)
    BadAndOperand*          =  61; (* operand of & is not of type BOOLEAN *)
    BadOrOperand*            =  62; (* operand of OR is not of type BOOLEAN *)
    UnaryNot*                =  63; (* operand of ~ is not of type BOOLEAN *)
    DyadicOperator*          =  64; (* incompatible operands of dyadic operator *)
    BadTimesOperand*        =  65; (* operand type inapplicable to * *)
    BadSlashOperand*        =  66; (* operand type inapplicable to / *)
    BadDivOperand*          =  67; (* operand type inapplicable to DIV *)
    BadModOperand*          =  68; (* operand type inapplicable to MOD *)
    BadPlusOperand*          =  69; (* operand type inapplicable to + *)
    BadMinusOperand*        =  70; (* operand type inapplicable to - *)
    BadEqualityTest*        =  71; (* operand type inapplicable to = or # *)
    BadRelationalTest*      =  72; (* operand type inapplicable to relation *)
    ExportOverride*          =  73; (* overriding method must be exported *)
    IllegalOperand*          =  74; (* operand inapplicable to (this) function *)
    IncompatibleAssignment*  =  75; (* incompatible assignment *)
    StringDoesNotFit*        =  76; (* string too long to be assigned *)
    ParmMismatch*            =  77; (* parameter doesn't match *)
    ParamCountsDiffer*      =  78; (* number of parameters doesn't match *)
    ResultMismatch*          =  79; (* result type doesn't match *)
    ExportMismatch*          =  80; (* export mark doesn't match with forward declaration *)
    BooleanRequired*        =  81; (* expression following IF, WHILE, or UNTIL is not BOOLEAN *)
    NotAProcedure*          =  82; (* not a procedure (or is an interrupt procedure) *)
    VarParmMismatch*        =  83; (* type of actual parm is not same as formal VAR-parm *)
    ResultTypeMismatch*      =  84; (* type of result expression differs from that of procedure *)
    InvalidCaseType*        =  85; (* type of case expression is neither INTEGER nor CHAR *)
    RvalueRequired*          =  86; (* this expression is not a valid rvalue *)
    IllegalUse*              =  87; (* illegal use of object *)
    UnsatisfiedForwardType*  =  88; (* unsatisfied forward reference *)
    UnsatisfiedForward*      =  89; (* unsatisfied forward procedure *)
    LenNotAnArray*          =  90; (* LEN not applied to array *)
    SystemNotImported*      =  91; (* SYSTEM not imported *)
    CannotGenSym*            =  92; (* generation of new symbol file not allowed *)
    NumberTooLarge*          =  93; (* number too large *)
    ProductTooLarge*        =  94; (* product too large *)
    DivisionByZero*          =  95; (* division by zero *)
    SumTooLarge*            =  96; (* sum too large *)
    DifferenceTooLarge*      =  97; (* difference too large *)
    NumericOverflow*        =  98; (* operation produced an arithmetic overflow *)
    CaseRangeTooLarge*      =  99; (* case range too large *)
    TooManyCases*            = 100; (* too many cases in case statement *)
    IllegalValue*            = 101; (* illegal value of parameter *)
    TooManyRecords*          = 102; (* too many record types *)
    TooManyPointers*        = 103; (* too many pointer types *)
    TooManyImports*          = 104; (* too many imported modules *)
    TooManyExpStruct*        = 105; (* too many exported structures *)
    TooManyExtensions*      = 106; (* record extension hierarchy too high *) (* remove from version 2 *)
    IdentifierTooLong*      = 107; (* identifier too long *)
    StringTooLong*          = 108; (* string too long *)
    AddressOverflow*        = 109; (* address overflow *)
    ReadOnly*                = 110; (* read only data *)
    NotAVariable*            = 111; (* not a variable *)
    StdProcedure*            = 112; (* calling standard procedure as a function *)
    StdFunction*            = 113; (* calling standard function as a procedure *)
    (* 114 is unused *)
    LongintRequired*        = 115; (* type must be LONGINT *)
    CharRequired*            = 116; (* type must be CHAR *)
    IntegerTypeRequired*    = 117; (* type must be an integer *)
    NotBasicType*            = 118; (* not a basic type *)
    TypeNotAllowed*          = 119; (* cannot be a type *)
    InvalidNewRecArr*        = 120; (* not a pointer to a record or bounded array *)
    InvalidNewDynarr*        = 121; (* incorrect number of dimensions for dynamic array creation *)
    NotDynarr*              = 122; (* not a dynamic array *)
    PointerRequired*        = 123; (* a pointer type is required *)
    FprintNew*              = 124; (* new object, compile to rewrite symbol file *)
    FprintRedefinedPublic*  = 125; (* redefined object *)
    FprintRedefinedPrivate*  = 126; (* redefined private part of object *)
    FprintDeleted*          = 127; (* object no longer visible *)
    FprintInconsistent*      = 128; (* object is not consistently imported *)
    CannotOpenSymfile*      = 129; (* unable to open symbol file for writing *)
    CannotFindSymfile*      = 130; (* unable to open symbol file for reading *)
    RecursiveImport*        = 131; (* recursive import not allowed *)
    TooManyHiddenFields*    = 132; (* too many hidden fields in a record *)
    OutOfMemory*            = 133; (* out of memory *)
    NeverUsed*              = 134; (* symbol declared but never used *)
    InvalidLen*              = 135; (* LEN dimension too large or negative *)
    NotAnArray*              = 136; (* index applied to a non-array type *)
    NotAnExtension*          = 137; (* guard or test type is not an extension of variable type *)
    BadGuardTest*            = 138; (* guarded or tested variable is not a pointer nor a VAR-parm *)
    SetElementErr*          = 139; (* set element type is not integer *)
    SetRangeErr*            = 140; (* lower bound greater than high bound of set *)
    ForwardPtrs*            = 141; (* too many forward pointers *)
    IllegalHalt*            = 142; (* halt value out of range *)
    FuncAsProc*              = 143; (* procedure call of a function *)
    ImportFailed*            = 144; (* import of a module failed *)
    InvalidInOp*            = 145; (* operand of IN is not integer or not a set *)
    IllegalConstValue*      = 146; (* illegal value of a constant *)
    GuardNeedsPointer*      = 147; (* guard or testtype is not a pointer *)
    NotAForVariable*        = 148; (* not a variable, or not suitable for FOR *)
(* 149 is an open slot *)
    IllegalIndexValue*      = 150; (* index < 0 or greater than maximum declared *)
    ExprTooComplex*  = 151; (* too few registers for expression *)
    FExprTooComplex* = 152; (* floating point expression too complex *)
    TooMuchCode* = 153;
    TooManyCaseStat* = 154;
    CodeSegOverflow* = 155;  (* order dependent *)
    ConstSegOverflow* = 156;(* order dependent *)
    CaseSegOverflow* = 157; (* order dependent *)
    DataSegOverflow* = 158; (* order dependent *)
    TooManyExpProc* = 159; (* too many exported procedures *)
    TooManyCommands* = 160; (* too many exported parameterless procedures *)
    TooManyRecordPointers* = 161; (* too many pointers encountered in record type *)
    ConstantPoolOverflow* = 162; (* too many constants *)
    TypeDescPoolOverflow* = 163; (* too many type descriptors *)
    CannotOpenObjFile* = 164; (* unable to open object file *)
    CannotOpenRefFile* = 165; (* unable to open reference file *)
END SKLERR.
